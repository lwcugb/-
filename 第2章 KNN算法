from numpy import *
import operator

def CreateDataSet():
	group  = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]])
	labels = ['A','A','B','B']
	return group, labels


#--------------------------------------KNN算法实例------------------------------------------------------------------
#--------------------------------------约会网站配对------------------------------------------------------------------
#-------------------------1将text文本数据转化为分类器可以接受的格式-----------------------------------------------------
def file2matrix(filename):
    #打开文件
    fr=open(filename)
    #读取文件每一行到array0Lines列表
    #read():读取整个文件，通常将文件内容放到一个字符串中
    #readline():每次读取文件一行，当没有足够内存一次读取整个文件内容时，使用该方法
    #readlines():读取文件的每一行，组成一个字符串列表，内存足够时使用
    array0Lines=fr.readlines()
    #获取字符串列表行数行数
    numberOfLines=len(array0Lines)
    #建立一个和数据样本等大的0矩阵
    returnMat=zeros((numberOfLines,3))
    #list存储类标签
    classLabelVector=[]
    index=0
    for line in array0Lines:
        #去掉字符串头尾的空格，类似于Java的trim()
        line=line.strip()
        #将整行元素按照tab分割成一个元素列表
        listFromLine=line.split('\t')
        #将listFromLine的前三个元素依次存入returnmat的index行的三列，第一个参数表示行，第二个参数表示列的范围
        returnMat[index,:]=listFromLine[0:3]
        #python可以使用负索引-1表示列表的最后一列元素，从而将标签存入标签向量中
        #使用append函数每次循环在list尾部添加一个标签值
        classLabelVector.append(int(listFromLine[-1]))
        index+=1
    return returnMat,classLabelVector

#----------------------------------------------2准备数据：归一化--------------------------------------------------
#计算欧式距离时，如果某一特征数值相对于其他特征数值较大，那么该特征对于结果影响要
#远大于其他特征，然后假设特征都是同等重要，即等权重的，那么可能某一特征对于结果存在严重影响

def autonorm(dataSet):
	minVals = dataSet.min(0)  #参数0按列选取最小值，如果换成1表示按行选取最小值
	maxVals = dataSet.max(0)  #参数0按列选取最大值，如果换成1表示按行选取最大值
	ranges  = maxVals-minVals
	normDataSet = zeros(shape(dataSet)) #创建与dataSet等大小的归一化矩阵，shape()获取dataSet的矩阵大小，即行数和列数
	m = dataSet.shape[0]  #获得dataSet的行数， shape[1]表示获取列数
	normDataSet = dataSet - tile(minVals,(m,1))  #将dataSet的每一行的对应列减去minVals中对应列的最小值
	normDataSet = normDataSet/tile(ranges,(m,1)) #归一化，公式newValue=(value-minvalue)/(maxVal-minVal)，还要注意这里的 '/'表示每一个矩阵内的数分别相除，而不是矩阵相除
	return normDataSet, ragnes, minVals

#------------------------------------------------3测试算法---------------------------------------------------------------
def datingClassTest():
	hoRatio=0.1 #设定测试的样本比例，不同的占比可能得到的错误率都会有所差别
	datingDataMat, datingLabels = file2matrix('datingDataTest2')  #从文本中提取得到数据特征，及对应的标签
	normMat,ranges,minVals = aotuNorm(datingDataMat) #对数据特征进行归一化
	m = normMat.shape[0] #得到行数
	numTestVecs = int(m*hoRatio) #测试样本数量
	errorCount = 0.0 #错误数据初始化
	for i in range(numTestVecs):
		classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],3) #利用分类函数classify0获取测试样本数据分类结果
		print("the classifier came back with: %d, the real answer is: %d" %(classifierResult,datingLabels[i])) #打印预测结果和实际标签
		if(classifierResult != datingLabels[i]):errorCount+=1.0 #如果预测输出不等于实际标签,错误数增加1.0
	print("the total error rate is: %f" %(errorCount/float(numTestVecs))) #打印最后的误差率
	
#------------------------------------------4运用已经完成的算法进行实际分类---------------------------------------------------
def classifyPerson():
	resultList = ['not at all','in small doses','in large doses']  #结果列表，对应的是datingTestSet2里面最后一列的1,2,3
	percentTats = float(raw_input("percentage of time spent playing video games?")) #在python3.x中，已经删除raw_input()，取而代之的是input(),另外输入的是文本类型的数据，要用float去转换
	ffMiles = float(raw_put("frequent filer miles earned per year?"))
	iceCream=float(input("liters of ice cream consumed per year?"))
	datingDataMat,datingLabels=file2matrix('datingTestSet2.txt')   #获得数据
	normMat,ranges,minValues=autoNorm(datingDataMat)  #归一化数据
	inArr=array([ffMiles,percentTats,iceCream])  #将输入的数据变成数组形式
	classifierResult = classify0((inArray-minVals)/ranges,norMat,datingLabels,3)
	print("You will probably like this person:", resultList[classifierResult-1]) #因为这里的labels是数字1,2,3，所以变成list的下标要减一
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	










